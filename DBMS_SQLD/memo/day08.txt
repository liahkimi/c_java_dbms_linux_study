day08. DML, 모델링

SQL문(쿼리문)의 종류

	SQL 명령어의 성격에 따라 분류
	1. DDL(Data Definition Language) : 데이터 정의 언어 
		- 테이블 조작 또는 제어 관련 쿼리문
	2. DML(Data Manipulation Language) : 데이터 조작 언어
		 - 데이터를 조작하는 쿼리문
	3. DCL(Data Control Language) : 데이터 제어 언어(권한)
	4. TCL(Transaction Control Language) : 트랜잭션 제어 언어 

DML(Data Manipulation Language)

	1. SELECT : 데이터 조회
	2. INSERT : 데이터 추가
	3. UPDATE : 데이터 수정
	4. DELETE : 데이터 삭제

SELECT

	테이블의 데이터를 조회한다

	SELECT 컬럼명, ... 
	FROM 테이블명 [WHERE 조건식] ;


INSERT

	테이블에 데이터를 삽입한다

	- 원하는 컬럼만 골라서 값을 저장할 때 사용하는 문법

	INSERT INTO 테이블명 (컬럼명, ...) 
	VALUES (값, ...);

	- 모든 컬럼에 값을 넣을 때 사용하는 문법
	INSERT INTO 테이블명 VALUES (값, ...);

	* 컬럼의 자료형에 알맞는 데이터를 삽입해야 한다

UPDATE

	테이블의 데이터를 수정한다
	update문에 조건문을 입력하지 않으면 모든 데이터가 수정된다

	UPDATE 테이블명 
	SET 컬럼명1 = 값1, 컬럼명2 = 값2, ... 
	[WHERE 조건식];

    
DELETE

	테이블의 데이터를 삭제한다
	delete문에 조건문을 입력하지 않으면 모든 데이터가 삭제된다

	DELETE FROM 테이블명 
	[WHERE 조건식];


모델링
	
	데이터베이스 시스템에서 데이터의 구조와 관계를 설계하는것

	1. 개념적 모델링 Conceptual Modeling
	    - 엔티티 도출. 비즈니스 요구사항 분석
	2. 논리적 모델링 Logical Modeling
    	- 데이터의 속성, 키, 엔티티들의 관계 정의
	3. 물리적 모델링 Physical Modeling
    	- 엔티티를 데이터베이스의 테이블로 구현
    	- 테이블, 인덱스, 키, 제약 조건 등을 정의

데이터의 무결성

	데이터의 정확성, 일관성, 유효성을 유지하여 결함없는 데이터를 유지 및 사용하는것

	1. 정확성 : 데이터는 애매하지 않아야 한다
	2. 일관성 : 각 사용자가 일관된 데이터를 볼 수 있도록 해야 한다.
	3. 유효성 : 데이터가 실제 존재하는 데이터여야한다.

무결성의 종류

	1. 개체 무결성 : 모든 테이블이 하나의 기본키(Primary key)를 가지는것
	(기본키로 지정된 컬럼은 고유한 값을 가지고, 빈값을 허용하지 않는다)
	2. 참조 무결성 : 두 테이블의 데이터가 항상 일관된 값을 가지도록 유지하는 것
	(주문 테이블의 주문 유저의 번호는 유저 테이블의 유저번호와 일치한다)
	3. 도메인 무결성 : 컬럼의 타입, NULL 값의 허용 등에 대한 사항을 정의하고 
	올바른 데이터가 입력되었는 지를 확인하는 것.

키(Key)

	데이터베이스 내의 레코드(행)를 고유하게 식별하거나 검색하는 데 사용되는 하나 이상의 속성(열)의 조합

	1. 모델링에서 사용
	    - 기본키, 외래키, 후보키, 대체키, 슈퍼키
	2. 테이블에서 사용(제약조건을 통해 구현)
	    - 기본키, 외래키

키의 종류

	1. 기본 키(Primary Key)    
		- 테이블 내의 각 행을 고유하게 식별하는 데 사용한다
		- 중복이 허용되지 않는다.
		- NULL 값이 허용되지 않는다

	2. 외래 키(Foreign Key)
		- 외래 키를 사용하여 두 테이블 간의 관계를 설정하고 참조 무결성을 유지한다
    
	3. 후보 키(Candidate Key)
	     - 기본키가 될수 있는 값(기본키의 후보)
     
	4. 대체 키(Alternate Key)  
	    - 후보키에서 기본키로 선택되지 않은 후보키들

	5. 슈퍼키(Super Key)
	    - 행을 고유하게 식별하기 위한 컬럼 또는 컬럼들의 조합

	슈퍼키 > 후보키 > 기본키 또는 대체키

제약조건

	1. PRIMARY KEY(PK)
	    - 고유한 값이며 각 행의 구분점으로 사용된다.
	    - 중복이 없고, NULL값을 허용하지 않는다

	2. FOREIGN KEY(FK)  
	    - 다른 테이블의 PK를 사용하며 중복이 가능하다
	    - 보통 테이블끼리 관계를 맺을 때 사용한다(참조 무결성)
	    - NULL값 을 허용
    
	3.  UNIQUE(UK)
	    - 해당 컬럼에서 중복값이 없는 고유값으로 사용해야 한다
	    - NULL값 허용

	4. CHECK(CK)  
	    - 컬럼의 값이 특정 조건을 만족해야 한다(값의 범위나 조건 사용)

	5. NOT NULL  
	    - 해당 컬럼의 값은 NULL값이 허용되지 않는다

	6. DEFAULT    
	    - 해당 컬럼의 값이 입력되지 않을 경우, 기본값으로 자동 입력된다
	    - 지정하지 않을 경우 NULL로 자동 사용된다


개념 모델링

	1. 요구사항
		모든 유저는 아이디, 비밀번호, 나이, 이메일, 포인트 금액을 가진다
		아이디는 중복될수 없고, 빈값이 저장될수 없다(고유한 값)
		비빌번호는 빈값이 저장될수 없다
		나이는 음수일 수 없다
		이메일은 중복될수 없다
		포인트 금액의 기본값은 0이다
	2. 엔티티 도출
		유저 엔티티. 엔티티의 속성 : 아이디, 비밀번호, 나이, 이메일, 포인트 금액 

논리 모델링

	1. 데이터의 속성 정의
		- 아이디: 문자. 중복불가. 빈값 저장 불가.
		- 비밀번호 : 문자. 빈값 저장 불가.
		- 나이 : 정수. 0보다 크거나 같아야함.
		- 이메일 : 문자, 중복불가.
		- 포인트 금액 : 정수. 기본값 0.
	2. 키 정의
		유저 엔티티의 기본키는 유저 아이디

물리 모델링

	테이블명 : TBL_USER
	USER_ID : VARCHAR2(1000) PRIMARY KEY
	USER_PASSWORD : VARCHAR2(1000) NOT NULL
	USER_AGE : NUMBER CHECK(USER_AGE ≥ 0)
	USER_EMAIL : VARCHAR2(1000) UNIQUE
	USER_POINT : NUMBER DEFAULT 0



DDL(Data Definition Langage) : 데이터 정의어

	테이블 조작, 제어 관련 쿼리문

	1. CREATE : 테이블 생성
	2. ALTER : 테이블 수정
	3. DROP : 테이블 삭제
	4. TRUNCATE : 테이블의 데이터 전체 삭제

CREATE

	테이블 생성
	CREATE TABLE 테이블명( 컬럼명 자료형(용량) [제약조건], ... );

 
	제약조건 정의 방법    
		컬럼 레벨 정의 : 하나의 컬럼을 정의하면서 같이 정의
		테이블 레벨 정의 : CREATE 쿼리 마지막에 정의
		NOT NULL 제약조건은 컬럼 레벨 정의만 가능
		테이블명_컬럼명_제약조건명 또는 시스템 구분_테이블명_제약조건명

테이블명 및 컬럼명 작명 주의사항
		
	이름은 중복 불가
	문자로 시작해야 한다
	특수문자는 _, $, # 사용 가능
	예약어 사용 불가
	공백 사용 불가
	최대 30글자까지 가능

ALTER

	테이블 수정(컬럼, 제약조건, 테이블명 등...)

	1. 테이블명 수정
		ALTER TABLE 테이블명 RENAME TO 새로운 테이블명;
	2. 컬럼 추가 
		ALTER TABLE 테이블명 ADD(새로운컬럼명 자료형(용량));
	3. 컬럼명 변경
		ALTER TABLE 테이블명 RENAME COLUMN 기존컬럼명 TO 새컬럼명;
	4. 컬럼 삭제
		ALTER TABLE 테이블명 DROP COLUMN 컬럼명;

	5. 컬럼 타입 수정 
		ALTER TABLE 테이블명 MODIFY(컬럼명 자료형(용량));

	6. 제약조건 추가
		ADD CONSTRAINT 제약조건의 이름 제약조건(컬럼명);
	7. 제약조건 삭제
		DROP CONSTRAINT 제약조건의 이름;

	* NOT NULL, DEFAULT 제약조건은 MODIFY를 통해 컬럼을 수정하면서 변경한다
	* 이름을 붙여 생성한 제약조건은 수정시 삭제후 다시 추가한다


DROP

	테이블 삭제
	DROP TABLE 테이블명;

	* DROP TABLE 부모테이블 CASCADE CONSTRAINT; 
	부모 테이블을 참조하는 제약조건과 부모테이블을 같이 삭제


TRUNCATE

	테이블의 데이터 전체 삭제(테이블이 아닌 데이터 삭제)
	TRUNCATE TABLE 테이블명;
	* TRUNCATE와 DELETE의 차이
    		delete : 테이블의 모든 데이터 삭제. 테이블의 용량은 감소하지 않음. rollback 가능. where 사용가능
		truncate : 테이블의 모든 데이터 삭제. 테이블의 용량 초기화. rollback 불가. where 사용 불가


외래키와 참조 무결성

	외래키 : 다른 테이블의 기본키를 참조하는키(컬럼)
	PK(기본키)를 가진 테이블 : 참조할 테이블(부모테이블)
	FK(외래키)를 가진 테이블 : 참조하는 테이블(자식테이블)
	부모 테이블의 기본키를 자식 테이블에서 외래키로 사용하는것

	* NULL값은 허용되지만, 참조하는 테이블에 존재하지 않는 값은 허용되지 않는다
	->  두 테이블에 존재하는 데이터가 동일하게 유지하는 참조 무결성을 유지할수 있다

	FK 제약조건 생성
		
	컬럼 레벨
	CONSTRAINT 외래키명 REFERENCES 참조 테이블명(참조할 컬럼명)

	테이블 레벨
	CONSTRAINT 외래키명 FOREIGN KEY (외래키로 지정할 컬럼명)
	REFERENCES 참조 테이블명(참조할 컬럼명)

	* ON DELETE CASCADE : 부모 테이블에서 행(PK)을 삭제할때, 자식테이블에서도 해당 PK를 참조하고 있는 행이 삭제된다


외래키가 존재하는 테이블 모델링

	1. 동물병원의 반려동물, 보호자의 정보를 저장하고 관리한다
	2. 보호자 정보는 이름, 주소, 핸드폰 번호를 가진다
	3. 반려동물 정보는 이름, 나이, 종, 보호자 정보를 가진다
	4. 반려동물의 보호자는 실제 존재하는 보호자여야 한다
	5. 보호자의 이름, 주소, 핸드폰 번호는 필수 정보이다
	6. 반려동물의 이름, 종, 보호자 정보는 필수 정보이다


	개념 모델링
		엔티티 도출
		- 반려동물 엔티티(이름, 주소, 핸드폰 번호)
		- 보호자 엔티티(이름, 나이, 종, 보호자 정보)

	논리 모델링
		- 반려동물 엔티티			- 보호자 엔티티
		=============			==============
		동물 번호(정수)		       보호자 번호(정수)
		이름(문자열)		       이름(문자열)		       
		나이(정수)		               주소(문자열)
		종(문자열)		               핸드폰 번호(문자열)
		보호자 번호(정수)
		
		* 기본키 지정 : 반려동물 엔티티(동물 번호), 보호자 엔티티(보호자 번호)
		* 외래키 지정 : 반려동물 엔티티(보호자 번호)

	물리 모델링

		TBL_GUARDIAN
		=====================================================
		GUARDIAN_NUMBER(PK)		NUMBER
		GUARDIAN_NAME			VARCHAR2(1000) NOT NULL
		GUARDIAN_ADDRESS		VARCHAR2(1000) NOT NULL
		GUARDIAN_PHONE_NUMBER		VARCHAR2(1000) NOT NULL


		TBL_PET
		======================================================
		PET_NUMBER(PK)			NUMBER
		PET_NAME 			VARCHAR2(1000)	NOT NULL
		PET_AGE				NUMBER		NOT NULL
		PET_SPECIES			VARCHAR2(1000)	NOT NULL
		GUARDIAN_NUMBER(FK)		NUMBER


시퀀스(SEQUENCE)

	오라클에서 중복되지 않는 값을 자동으로 순차적으로 생성하는것
	일반적으로 PK값에 중복값을 방지하기 위해 생성하여 사용한다


시퀀스 생성

	CREATE SEQUENCE 시퀀스명;
	START WITH 시작숫자
	INCREMENT BY 증감숫자
	일반적으로는 옵션을 주지 않고 생성하여 사용한다

시퀀스 삭제

	증가된 시퀀스를 감소시킬수 없기때문에 잘못된 값으로 증가시켰을 경우에는 삭제후 다시 생성하여 사용한다
	DROP SEQUENCE 시퀀스명;

시퀀스 사용

	현재 시퀀스 값 : 시퀀스명.CURRVAL
	다음 시퀀스 값(시퀀스 값이 증가된다) : 시퀀스명.NEXTVAL
	시퀀스 생성후 NEXTVAL을 1회 호출해야 CURRVAL을 통해 현재 시퀀스 값을 확인할수 있다
