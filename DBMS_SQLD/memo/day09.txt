day09. 조합키, 정규화, 뷰(VIEW)


조합키(복합키)

	두개 이상의 컬럼을 PK로 지정하는 것
	테이블에 한 개의 PK만 존재할 수 있지만 조합키를 사용하면 두 개 이상의 컬럼을 
	하나의 PK로 사용할 수 있다.

이상현상

	데이터베이스의 설계가 잘못되어 발생하는 문제


	직원
	===============================================================================
	사원번호(PK)   이름     생년월일             부서정보              급여

	1           스티븐   2010-12-31      영업부, 서울시.. 01234     300
	2           홍길동   2011-10-01      영업부, 서울시.. 01234     250
	3           나길동   2003-05-01      사업부, 경기도...02345     200
	4     ....


	1. 삽입 이상
		- 새로운 데이터를 삽입하기 위해 불필요한 데이터도 삽입해야하는 문제
		- 새로운 사원을 등록할때 부서의 주소, 우편번호를 같이 입력해야 한다
	
	2. 갱신이상
		- 중복 행 중에서 일부만 변경하여 데이터가 불일치하게 되는 모순의 문제
		- 부서의 주소가 변경되었을때 해당하는 부서의 모든 사원 데이터를 수정해야 한다
	
	3. 삭제이상
		- 행을 삭제했을 때 필요한 데이터도 같이 삭제되는 문제
		- 부서정보를 삭제할때 사원의 정보도 같이 삭제하게 된다

정규화(Normalization)

	데이터의 중복을 최소화하고(독립성), 데이터의 무결성을 향상시키는 방법
	이상현상을 제거하기 위한 작업
	6차 정규화까지 있으나 일반적으로 3차 정규화까지만 진행한다(과도한 정규화는 데이터를 조회할때 복잡해짐)
	반정규화(역정규화) : 데이터베이스의 성능 최적화 및 쿼리 실행속도를 빠르게 하기 위해 데이터 중복을 허용하는것

	1. 1차 정규화 : 모든 컬럼은 하나의 고유한 값(원자값)을 가지고, 모든 행은 고유한 식별자(PK)를 가진다
	2. 2차 정규화 : 기본키가 조합키(복합키)인 경우 조합키의 일부분에만 종속되는 속성이 존재하는 경우(부분함수 종속성 제거)
	3. 3차 정규화 : 기본키가 아닌 컬럼이 다른 컬럼을 결정하는 경우(이행함수 종속성 제거)


1차 정규화

	모든 컬럼은 하나의 값을 가져야 한다 
	부서정보의 컬럼은 하나의 값이 아닌 여러개의 값(다중값)을 사용한다
	
	직원
	===========================================================
	사원번호   이름    생년월일      부서정보                 급여

	1           스티븐 2010-12-31  영업부, 서울시..  01234     300
	2           홍길동 2011-10-01  영업부, 서울시..  01234     250
	3           나길동 2003-05-01  사업부, 경기도... 02345     200
	4     ....


	하나의 컬럼이 하나의 값을 가질수 있도록 컬럼을 분리한다


	직원 PK : (사원번호, 부서명)
	===============================================================================
	사원번호(PK)  이름    생년월일        부서명    부서주소   부서 우편번호     급여

	1          스티븐   2010-12-31    영업부    서울시..  01234     300
	2          홍길동   2011-10-01    영업부    서울시..  01234     400
	3          나길동   2003-05-01    사업부    경기도..  02345     200 
	4     ....



2차 정규화

	컬럼은 기본키 전체에 종속되어야 한다
	조합키로 기본키를 사용할 경우 조합키의 일부분에만 종속되는 속성이 없어야 한다
	만약 PK를 (사원번호, 부서명)으로 사용한다면 부서명만 알아도 부서의 주소, 우편번호를 알수 있다


	직원 테이블
	=============================================================================
	사원번호(PK)  이름    생년월일       부서명     주소    우편번호     급여

	1          스티븐   2010-12-31   영업부    서울시..  01234     300
	2          홍길동   2011-10-01   영업부    서울시..  01234     400
	3          나길동   2003-05-01   사업부    경기도..  02345     200 
	4     ....



	사원 테이블과 부서 테이블을 분리한다
	부서테이블의 부서번호를 PK로 지정하고, 직원 테이블의 외래키(FK)로 지정한다



	직원
	==================================================================
	사원번호(PK)  이름    생년월일    부서번호(FK)   급여

	1     스티븐 2010-12-31      1      300
	2     홍길동 2011-10-01      1      250
	3     나길동 2003-05-01      2      200
	4     ....


	부서

	===================================================================
	부서번호(PK)      부서명     주소      우편번호    
	1              영업부     서울시..    01234   
	2              사업부     경기도..    02345     

	부서를 분리할 뿐만 아니라 외래키를 지정해놓으면 사원이 실제 존재하지 않는 사원 번호를 가지는것을 막을수 있다!


3차 정규화

	기본키가 아닌 컬럼이 다른 컬럼을 결정하는 경우(기본키가 아닌 컬럼에 종속적인 경우)
	부서테이블에서 우편번호만 알아도 부서의 주소를 알수 있다
	부서테이블에서 주소만 알아도 우편번호를 알수 있다


	부서

	===================================================================
	부서번호(PK)      부서명     주소      우편번호    
	1              영업부     서울시..    01234   
	2              사업부     경기도..    02345    



	부서와 부서 주소테이블을 분리한다
	부서 주소 테이블의 주소 번호를 부서 테이블의 FK로 지정한다


	부서
	===================================================================
	부서번호(PK)   부서명    주소번호(FK)
	1            영업부       1  
	2            사업부       2       


	부서 주소
	===================================================================
	주소번호(PK)    주소          우편번호
	1            서울시..        01234   
	2            경기도..        02345    



최종 테이블

	직원                   부서                  부서 주소
	=============       =============       =============       
	사원번호(PK)           부서번호(PK)          주소번호(PK)
	이름                  부서명               주소
	생년월일               부서 주소번호(FK)      우편번호
	부서번호(FK)   
	급여


뷰(VIEW)

	기존 테이블은 그대로 놔둔 채 필요한 컬럼들 및 새로운 컬럼을 만든 가상 테이블
	일반적으로 데이터를 조회하기 위해 사용한다

	독립성 : 다른 곳에서 원본 테이블에 접근하지 못한다
	편리성 : 원하는 형태로 뷰를 만들어, 복잡한 조회 쿼리를 간결하게 사용할수 있다
	보안성 : 원하는 정보만 가지고 뷰를 생성하여, 사용자에게 일부 정보를 가릴수 있다

	1. 뷰 생성 
	CREATE VIEW 뷰 이름 AS 쿼리문;

	CREATE OR REPLACE VIEW 뷰 이름 AS 쿼리문;
	* 뷰가 존재하지 않을 경우 생성, 존재할경우 수정
	* 뷰의 이름은 원본테이블과 같은 이름 사용 불가

	2. 뷰 삭제 
	뷰를 삭제해도 원본 테이블의 데이터는 삭제되지 않는다

	DROP VIEW 뷰 이름 [RESTRICT / CASCADE];
	RESTRICT : 뷰를 다른곳에서 참조하고 있다면 삭제 취소
	CASCADE : 뷰를 참조하는 다른 뷰나 제약조건까지 모두 삭제



