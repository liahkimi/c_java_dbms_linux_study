day04. 인터페이스

복습
	casting
		객체의 값을 타입(자료형)을 변환한다
		-> 객체가 하나의 자료형만을 가지지 
		않는다(상속)

		* up casting
			상위 타입 변수에 하위타입의
			값을 저장한다

			상위타입 변수 = 하위타입 값;

		* down casting
			하위 타입 변수에 up casting 된 			상위타입의 값을 저장한다
			
	추상클래스
		추상메소드가 1개 이상 선언된 클래스
		* 일반 필드와 일반 메소드를 가질수 있다
		
		-> 추상메소드(미구현된)를 가지기 때문에
		독립적으로 객체화 할수 없다(new 생성자 호출불가)

	추상메소드
		구현부가 없는 메소드(미구현된 메소드)
		-> {} 중괄호가 없다

	추상클래스 사용 이유
		추상메소드를 가진 추상클래스를 상속받는 
		자식클래스(일반클래스)는 반드시 상속받은 
		추상메소드를 구현해야 한다 -> 메소드 오버라이딩


인터페이스(interface)
	
	값과 기능을 일관화 시키기 위한 틀
	-> 개발자와 사용자간의 상호적인 약속

	멤버로 상수와 추상메소드만 존재한다

	* 인터페이스는 생성자를 가지지 않고, 클래스가 아니기 때문에
	객체화 할수 없다
	* 인터페이스도 하나의 타입이다

인터페이스 선언

	interface 인터페이스명 {
		상수
		추상메소드
	}
	
	* 인터페이스에서 선언하는 메소드는 구현이 아닌 
	형식(선언부)을 통일하기 위한 목적으로 사용한다

인터페이스의 멤버

	1. 모든 변수는 public static final 이다
	-> 생략해도 자동으로 붙는다

	2. 모든 메소드는 public abstract 이다
	-> 생략해도 자동으로 붙는다


인터페이스 구현(implement)

	인터페이스는 클래스에서 구현한다

	class 클래스명 implements 인터페이스명{

		추상메소드 구현(메소드 오버라이딩)
	}
	

	인터페이스를 구현하는 클래스는 해당 인터페이스의 추상메소드를
	구현해야하는 강제성을 가진다
	
	인터페이스를 구현하는 클래스 : 하위타입(자식)
	인터페이스 : 상위타입(부모)
	-> 인터페이스를 구현하는 클래스는 해당 인터페이스의 타입을 가진다

인터페이스 사용 이유

	1. 실제 구현 클래스의 내용을 알지 못해도 개발코드로 객체를
	사용할수 있다(정보 은닉)
	2. 구현 클래스들이 독립적으로 구현되고, 사용될수 있다(모듈화)
	3. 여러 클래스에게 멤버의 일관된 규격을 제공할수 있다(표준화)
	4. 클래스들을 그룹화 시킬수 있다(마커 인터페이스)
	5. 추상클래스 : 추상화와 모듈화에 중점 
	   인터페이스 : 정보은닉과 모듈화에 중점

클래스 상속과 인터페이스 구현

	일반 클래스, 추상 클래스 -> 단일 상속(extends) -> 일반 클래스, 추상 클래스
	인터페이스 -> 구현(implements) -> 클래스

	* 인터페이스 -> 다중 상속 -> 인터페이스
	
	1. 상속과 구현은 별개이다. 즉, 하나의 클래스에 상속과 구현을 동시에 할수 있다
	2. 인터페이스는 여러개의 인터페이스를 상속받을수 있다

	*** 자바의 클래스는 단일상속, 다중구현 이다 ***

다중상속
	자바는 모호성때문에 클래스의 다중상속을 지원하지 않는다
	인터페이스는 인터페이스를 상속받으며, 여러개의 인터페이스를 
	상속받을수 있다


다중 인터페이스 구현
	
	하나의 클래스에서 여러개의 인터페이스를 구현한다
	
	class 클래스명 implements 인터페이스1, 인터페이스2...{


	}

인터페이스 상속
	
	interface 인터페이스명 extends 인터페이스1, 인터페이스2..{


	}

	* 인터페이스끼리만 상속이 가능하다
	* 인터페이스는 다중상속이 가능하다


다중 인터페이스 구현과 인터페이스의 다중상속

	1. 다중 인터페이스 구현
		클래스 1개 인터페이스 여러개 구현

		* 인터페이스1 타입으로 up casting
			인터페이스1의 추상메소드에만 접근 가능

		* 인터페이스2 타입으로 up casting
			인터페이스2의 추상메소드에만 접근 가능

	2. 인터페이스의 다중상속 구현
		클래스 1개 인터페이스 1개(다른 인터페이스를 상속받음) 구현
		
		* 인터페이스3(인터페이스1, 인터페이스2 상속받음) up casting
			인터페이스1, 2, 3의 추상메소드 접근가능

		* 인터페이스2 타입으로 up casting
			인터페이스2의 추상메소드 접근가능

		* 인터페이스1 타입으로 up casting
			인터페이스1의 추상메소드 접근가능

인터페이스의 추가된 기능
	앞으로는 인터페이스에 구현된 일반 메소드를 선언할수 있다!

	1. default 메소드(일반 메소드)를 선언할수 있다
		default 리턴타입 메소드명(자료형 매개변수명) {

		}

	2. static 메소드를 선언할 수 있다
		static 리턴타입 메소드명(자료형 매개변수명) {

		}

	3. private 메소드를 선언할 수 있다
		private 리턴타입 메소드명(자료형 매개변수명) {


		}

모호성(ambiguity)
	
	하나의 자식이 여러 부모를 상속받을때, 부모멤버에 동일한 멤버가 있다면
	어떤 부모의 멤버인지 알수 없다. 이를 모호성이라고 한다


	1) 두개의 인터페이스 내에 선언부가 같은 추상메소드가 선언되어 있다
		-> 구현하는 클래스에서 구현하는(재정의) 메소드가 사용된다

	2) 두개의 인터페이스 내에 선언부가 같은 일반 메소드(default 메소드)가 
	선언되어 있다	
		-> 구현하는 클래스에서 2개중에 1개를 재정의하여 사용한다

	3) 상속받은 메소드와 구현하는 인터페이스의 일반 메소드의 선언부가 동일하다
		-> 상속받은 메소드가 사용된다


























		

	





