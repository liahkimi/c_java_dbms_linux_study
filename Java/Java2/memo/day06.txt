day06. Object 클래스, String, 컬렉션 프레임워크

Object 클래스

	모든 클래스들의 최상위 부모 클래스
	-> 모든 클래스는 Object 클래스를 상속받는다

	1. toString() : 객체 자신의 정보를 반환한다
	2. equals() : 다른 객체와 자신이 가진 실제값을 비교한다 
	3. hashCode() : 객체의 hashCode 값을 반환한다

toString()
	
	Object 클래스의 toStrng() 메소드는 참조값을 
	문자열 형태로 반환한다
	-> 클래스경로와이름@16진수로 변환된(해시코드값)
	
	참조변수(객체)를 print(), println() 등의 출력메소드로
	출력하면 항상 toString() 메소드가 자동 호출된다

	만약 toString() 을 통해 반환되는 문자열을 바꾸고 싶다면
	재정의하여 사용한다

equals()
	
	사실 Object 클래스의 equals() 메소드는 관계연산자
	== 과 같다(두 객체의 주소값 비교)

	그러나 객체가 가지고 있는 정보(필드, 타입)이 같다면
	서로 동등한 객체다 라고 판단하기 위해 equals() 메소드를
	재정의 하여 사용한다

	-> String 클래스의 equals() 메소드는 재정의되어
	두 문자열 객체의 주소값이 아닌 값을 비교한다
	-> 문자열의 비교는 equals() 메소드를 사용한다

	동일성(identity) : 객체의 주소값을 비교(==)
	동등성(equality) : 객체의 주소값은 다르지만,
	가지고있는 정보의 동등성 비교(재정의된 equals())


hashCode()
	
	Object 클래스의 hashCode()는 객체의 주소값(컴퓨터
	메모리 상의 주소값)을 특정 알고리즘을 거쳐서 정수값으로
	반환한다

	* Object 클래스 hashCode() : native 키워드
	-> 다른 언어(C언어 또는 C++ 등..)로 구현되어 있는것을
	자바에서 사용하려고 할때 붙이는 키워드


	자바에서는 equals() 메소드를 재정의하면, 반드시
	hashCode() 메소드도 재정의 하도록 권장한다

	두 객체가 equals() 메소드 재정의를 통해 동등한
	객체라고 재정의하였다면, 두 객체의 hashCode() 값도
	동일한 값이 나오도록 재정의한다
	-> 두 메소드를 통해 중복을 판단하는 개념이 존재하기때문에


	컴퓨터 메모리상의 주소값
	-> JVM이 hashCode()를 통해 정수값으로 변환
	-> toString() 를 통해서 다른 문자열과 연결

	* Objects : 클래스들에서 사용가능한 여러가지
	편리한 메소드가 들어있는 클래스
	
Wrapper 클래스
	
	기본 자료형을 클래스로 사용하기 위한 클래스

	기본타입		wrapper 클래스
	=====================================
	int		Integer
	long		Long
	double		Double
	float		Float
	boolean		Boolean
	char		Character

Boxing
	기본 자료형의 값을 wrapper 클래스의 객체(인스턴스)로 
	변환

	1. 클래스명 객체명 = new 클래스명(기본자료형의 값);
	2. 클래스명 객체명 = 클래스명.valueOf(기본자료형의 값);
	3. 클래스명 객체명 = 기본 자료형의 값 -> auto boxing

Unboxing

	wrapper 클래스 객체에 저장된 값을 기본 자료형의 값으로
	변환

	1. 기본자료형 변수명 = 객체.000Value();
	2. 기본자료형 변수명 = 객체; -> auto unboxing

wrapper 클래스 사용 이유

	1. 기본 자료형을 클래스로 박싱하면 해당 클래스의
	다양한 메소드를 사용할 수 있다

	2. 기본자료형을 작성할수 없는 개념들이 있기때문에
	(제네릭) -> 매개변수로 기본자료형이 아닌 클래스 타입을
	사용해야 하는 경우

String 클래스

	String str1 = "a";
	String str2 = "a";

	-> String constant pool에서 생성하려는 문자열과
	똑같은 문자열의 값을 가진 객체가 있다면 새로 객체를
	생성하지 않고, 기존 객체의 주소값을 재사용한다

	-> 만약 문자열의 값이 기존 객체의 문자열 값과
	동일하지 않다면, 새로운 객체를 생성한다

	String str3 = new String("a");

	-> string constant pool이 아닌 heap 영역에
	새로운 객체를 생성한다

	* String 클래스는 불변이다(immutable)
	-> str1 = "b"; 로 코드를 실행했을때 str1에 
	담긴 객체의 값을 변경한게 아니라(a->b) "b" 문자열
	값을 가지고 있는 새로운 객체가 string constant pool
	에 생성되고 이 객체의 주소값을 str1에서 사용하게 된다

	즉, 기존에 생성된 객체의 문자열값 "a"를 바꾸지 못하기
	때문에 문자열 클래스는 불변이다


StringBuffer, StringBuilder 클래스

	가변 문자열 클래스
	-> 객체가 가지고 있는 문자열 값을 수정할수 있다

	* StringBuffer : 멀티쓰레드 대처가능
	* StringBuilder : 멀티쓰레드 대처불가(일반적으로 사용)

	1. append() : 기존 문자열 뒤에 새로운 문자열 더하여 반환
	2. delete() : 시작 위치부터 끝 위치 전까지 문자열 삭제해서
	반환
	3. insert() : 시작위치부터 새로운 문자열 삽입후 반환
	4. reverse() : 문자열을 반대로 반환

	* 두개의 클래스는 equals() 메소드가 재정의되어 있지 않아
	문자열 값의 비교는 compareTo() 같은 메소드를 사용한다

String 클래스의 메소드

	charAt()
		문자열에서 해당 인덱스 번호의 문자를 
		char 타입으로 반환

	indexOf()
		특정 문자나 문자열을 앞에서부터 찾아 
		처음으로 찾게되는 인덱스를 반환. 없을경우 -1을 반환

	split()
		구분문자를 기준으로 문자열을 잘라 배열에 담아 반환

	substring(start, end)
		시작 인덱스 번호 ~ 끝 인덱스번호 -1 
		까지의 문자열 반환

	length()
		문자열의 길이를 반환

	strip()
		문자열 앞뒤의 공백 제거

알고리즘(algorithm)
	문제 해결 절차 및 순서

자료구조
	데이터를 효율적으로 관리할수 있게 조직화시켜 저장하는 방법
	* ADT(추상 데이터 타입) : 이런 특징과 연산이 가능한 구조는
	앞으로 배열이라고 부른다...


컬렉션 프레임워크(collection framework)

	기존에 존재했던 자료구조에 인터페이스로 설계된 기능을
	클래스를 통해 제공하여 데이터 관리에 용이한 자료구조
	객체를 구조화한것

	-> 자료구조를 구현해놓은 클래스와 인터페이스들

	1. Collection 인터페이스
		- List 인터페이스
			- ArrayList 클래스
			- Vector 클래스
			- LinkedList 클래스

		- Set 인터페이스
			- HashSet 클래스
			- TreeSet 클래스

	2. Map 인터페이스
		- HashMap 클래스
		- TreeMap 클래스

	3. Collections 클래스
		컬렉션 객체에서 사용 가능한 다양한 메소드 제공

제네릭(generic)
	
	데이터의 타입을 일반화 한다
	클래스나 메소드 선언시 일반화하여 사용할 데이터타입을
	컴파일때 미리 지정하는 방법

제네릭 선언 및 생성

	public class 클래스명<T> {...}
	public interface 인터페이스명<T> {...}

	T : 타입 변수(type variable)
		<T> : Type
		<E> : Element
		<K> : Key
		<N> : Number
		<V> : Value

	-> 컬렉션 객체에 저장되는 데이터 타입을 기재해준다
	클래스명<타입명> 객체명 = new 클래스명<타입명>();

	* 지정할 타입에 제한을 둘수 있다
	* 따로 다운 캐스팅 할 필요없다(Object 클래스와 비교)

	<? extends 부모클래스>
		-> 부모 클래스 또는 부모 클래스를 상속받은
		자식 클래스의 객체만 타입으로 지정가능

	<? super 자식클래스>
		-> 자식 클래스 또는 자식클래스가 상속받고 있는
		부모 클래스의 객체만 타입으로 지정가능

List 인터페이스
	
	list interface extends Collcetion
	Collecion 인터페이스를 상속받는다
	
	데이터의 순서를 보장한다
	중복된 값을 허용한다

List 구현 클래스

	1. Vector : 용량관리, 보안성 강화, 처리량 감서
	-> 예전에 주로 사용하던 클래스

	2. LinkedList : 추가, 삭제는 빠르지만 탐색이 상대적으로
	느리다

	3. ArrayList : 배열과 동일하게 인덱스로 데이터를 관리한다
	컬렉션 클래스중에서 가장 많이 사용하는 클래스
	추가, 삭제는 상대적으로 느리지만 탐색이 빠르다

ArrayList 와 배열의 차이

	배열은 길이에 제한을 두어야 할때 자주 사용한다
	ArrayList는 길이에 제한을 두지 않을때 자주 사용한다

* 과제 : 다음주 토요일 수업까지 ArrayList, HashSet, HashMap
	오라클 API 문서 사이트에서 추가, 수정, 삭제, 조회 
	메소드 찾기



































	































