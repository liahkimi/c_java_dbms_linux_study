day02. 메소드 오버라이딩, 접근 제한자, final

복습
	상속
		하나의 클래스가 기존 클래스의
		멤버와 타입을 상속받는것

	상속 문법
		* extends 상속받을 클래스

		class A {
			* 부모 클래스(상속해주는 클래스)				* 슈퍼 클래스(상위 타입)
		}

		class B extends A{
			* 자식 클래스(상속받는 클래스)
			* 서브 클래스(하위 타입)
		}

	super() 

		부모 클래스의 생성자

		자식 클래스의 생성자는 항상 최상단에서
		부모 클래스의 생성자를 호출한다(직접
		작성하지 않아도 자동 호출)

		-> 자식 객체가 생성될때 부모 객체도
		같이 생성된다

	super
		부모 객체의 주소값(참조값)이 저장된
		자동으로 생성되는 변수

	메소드 오버라이딩
		자식 클래스에서 부모 클래스로부터 물려
		받은 메소드를 재정의한다

		-> 선언부는 동일하고, 구현부를 변경한다

		* 메소드 오버로딩 : 중복된 메소드 이름
		으로 새로운 메소드를 정의하는것

		
		리턴타입 메소드명(자료형 매개변수명) -> 선언부(signature)
		{
			실행할 코드	      -> 구현부(body)

		}

접근 제한자(Access Modifier)
	
	제한자 : 클래스, 변수 또는 메소드의 선언부에 함께 사용해
	부가적인 의미를 부여하는 메소드

	변수, 메소드, 클래스의 접근 권한을 제어하는것


	1. public	: 모든 곳에서 접근가능. 대표클래스를 의미한다
	2. protected	: 같은 패키지에서만 접근가능. 
			단, 다른 패키지라도 자식 클래스라면 접근이 가능하다
	3. default	: 같은 패키지에서만 접근가능.
			별도로 명시하지 않고, 접근 제한자를 생략시 자동으로 default가 된다
	4. private	: 같은 클래스에서만 접근이 가능하다
	
	* public > protected > default > private

접근 제한자 선언 위치

	1. 접근 제한자 class 클래스명 -> 클래스
	2. 접근 제한자 자료형 필드명 -> 필드
	3. 접근 제한자 클래스명() -> 생성자
	4. 접근 제한자 리턴타입 메소드명() -> 메소드

캡슐화
	객체 내부의 멤버를 객체 외부에서 볼수 없도록
	캡슐화 한다. 접근이 필요한 값의 경우 public
	메소드를 통해 접근을 허용하고, 그외의 값들은
	모두 캡슐화를 통해 정보를 은닉한다

	1. 필드를 보호할 수 있다
	2. 메소드에서 필드에 들어갈 값을 검증한후 
	필드에 대입할수 있다
	3. 외부에서 사용할 필드의 값을 정제한 후 
	값을 제공할수 있다

	-> 데이터의 정보가 필요할때, 데이터에 직접 접근하지 말고
	데이터를 접근할수 있는 메소드를 통해 사용한다

getter/setter 메소드

	1. getter
		private 한 필드를 객체 외부에서 값을 
		불러오기 위해 구현하는 메소드
		get + 필드명(필드 타입이 boolean이면
		is)

	2. setter
		private 한 필드에 값을 객체 외부에서
		저장하기 위해 구현하는 메소드
		set + 필드명

final(최후의, 마지막의)

	1. final 클래스
		해당 클래스가 상속의 마지막 클래스이다
		-> 다른 클래스가 상속받을 수 없다 

	2. final 메소드
		해당 메소드를 수정할수 없다
		-> 해당 메소드는 오버라이딩 할수 없다

	3. final 필드(변수)
		해당 필드의 초기값을 변경할수 없다(상수)
		-> 고정된 값으로 사용해야 한다

객체 타입 비교(instanceof)
	
	a instanceof A : 객체 instanceof 클래스명
	a 객체가 클래스 A 타입이라면 true, 아니라면 false
	-> 하나의 객체가 여러개의 타입을 가진다

클래스의 객체 타입 형변환

	객체의 값(주소값)을 다른 형태로 바꾼다
	* 객체가 가지고 있는 타입으로만 형변환 가능하다

	1. up casting(자동 형변환, 묵시적 형변환) 
		하위 타입의 값을 상위 타입으로 형변환
		하위 타입의 객체를 상위 클래스 타입으로 변환한다
		-> 자식 객체를 부모 클래스 타입으로 변환한다

		부모클래스명 객체명 = new 자식클래스명();
		부모클래스 변수 = 자식 객체 값

	2. down casting(강제 형변환, 명시적 형변환)
		상위 타입의 값을 하위 타입으로 형변환
		-> 부모 객체를 자식 클래스 타입으로 변환한다(X)
		-> 부모 클래스는 자식 클래스 타입을 가지지 
		않기때문에 안된다

		up casting된 자식객체를 다시 자식 클래스
		타입으로 변환한다(O)

		자식클래스 객체명 =(자식클래스)up casting된 자식객체;

Casting을 사용하는 이유 

	1. up casting : 다양한 타입을 한번에 관리하기 위해서
	2. down casting : up casting 된 자식에서 자식 클래스의 멤버를
	사용해야할 경우


	* Parent 클래스
	* Child 클래스(extends Parent)
	* GrandChild 클래스(extends Parent)
	
	Parent p = new Parent();
	Parent p = new Child(); -> up casting
	Parent p = new GrandChild();

	접근제한자 Parent useSleep(Parent p) {
		parent.sleep();

		if(parent instanceof Child){
			((Child)parent).childStudy();
	
		}

	}





















	






	

	




