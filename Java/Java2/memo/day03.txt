day03. casting, 추상 클래스

복습
	상속
		기존 클래스의 멤버, 타입을 새로운 클래스에서
		상속 받는것
		-> 하나의 객체가 여러개의 타입을 가질수 있다

	상속 문법
		* extends 상속받을 클래스명

		class A {

		}
		
		class B extends A{
		
		}

		* A : 부모 클래스, 슈퍼 클래스(상위타입)
		* B : 자식 클래스, 서브 클래스(하위타입)

	메소드 오버로딩과 메소드 오버라이딩
		메소드 오버로딩 : 매개변수의 형태를 달리하여,
		중복된 메소드의 이름으로 새로운 메소드를 정의하는것

		메소드 오버라이딩 : 상속받은 메소드를 자식 클래스에서
		재정의하는것(구현부를 재정의하는것)

	접근 제한자

		1. public	: 모든곳에서 사용 가능
		2. protected	: 같은 패키지에서 사용 가능
				다른 패키지여도 자식 클래스에서는 사용 가능
		3. default	: 같은 패키지에서 사용 가능
		4. private	: 같은 클래스에서만 사용 가능

		* 같은 패키지 : protected, default
		* 같은 클래스 : private

		-> 데이터를 직접 접근하지 말고, 데이터를 접근할수 있는 메소드를 사용한다
		* 무분별한 setter 사용을 하지 말자

클래스의 객체 타입 형변환(casting)

	형변환 -> 자료형을 변환한다 -> 객체의 타입을 변환한다
	
	1. up casting(자동 형변환)
		부모클래스 객체명 = new 자식클래스명();
		부모클래스 객체명 = 자식 클래스의 객체;
		* 하위타입의 객체가 상위 타입으로 변환된다

	2. down casting(강제 형변환)
		
		* 상위 타입은 하위타입을 가지지 않는다
		-> 부모클래스는 자식클래스 타입을 가지지 않는다

		up casting된 자식객체를 자식클래스 타입으로
		변환할때(원상복귀 시킬때)

		자식클래스 객체명 = (자식클래스) up casting 된 자식객체;
		((자식클래스)up casting된 자식객체).필드명;
		((자식클래스)up casting된 자식객체).메소드명();

		-> down casting된 객체에서 필드나 메소드를 사용한다
	
		* 재정의된(오버라이딩) 메소드는 up casting 상태에서 호출 가능


	* 기본자료형 강제 형변환
	double -> int
	(int)10.7	-> (자료형)객체

	int -> double
	-> double num = 10;
	-> 변수에 값을 저장할때 서로 자료형이 일치하지 않으면,
	자동 형변환이 진행된다


Casting을 사용하는 이유

	-> 객체를 형변환을 왜 할까?

	up casting : 다양한 타입을 한번에 관리하기 위해서
	down casting : up casting된 자식객체에서
	자식 클래스의 필드나 메소드를 사용해야 하는 경우

casting 연습
	1. 판매자, 구매자가 로그인 기능을 사용한다
	2. 판매자 필드 : 아이디, 비밀번호, 판매자 번호
	3. 구매자 필드 : 아이디, 비밀번호, 포인트
	4. 판매자 또는 구매자를 전달받아서 로그인을 시킨다


다형성(polymorphism)
	*** 자바의 다형성 검색해서 자료 읽고 정리하기 ***
	하나의 타입으로 다양한 객체를 사용할수 있는것

	1. 상속
	2. 메소드 오버라이딩(상속받은 메소드를 재정의하는것)
	3. 메소드 오버로딩(하나의 클래스 안에서 같은 이름
	으로 새로운 메소드를 선언하는것)

추상 메소드(abstract method)
	미구현된 메소드(구현부가 없는 메소드)
	선언만 되고, 구현이 되지 않은 메소드
	
	abstract 리턴타입 메소드명(자료형 매개변수명);
	
	1. abstract 키워드를 사용한다
	2. 마지막에 세미콜론을 사용한다
	3. 추상메소드를 1개 이상가지고 있는 클래스는
	추상클래스 선언한다

추상 클래스(abstract class)

	한개 이상의 추상 메소드를 가지고 있는 클래스
	1. 미구현된 멤버(추상 메소드)를 가지고 있기때문에
	독립적으로 객체화 할수 없다(객체 생성 불가)
	2. 추상 클래스를 상속받는 자식클래스는 반드시
	상속받은 추상메소드를 구현해야하는 강제성을 가진다

추상 클래스 선언

	abstract class 클래스명{
		필드
		일반 메소드
		추상 메소드
	}

추상 클래스 사용 이유
	1. 자식 클래스간의 공통적인 메소드 이름을 통일
	2. 반드시 구현해야하는 메소드를 선언함으로써
	공통 규격을 제공(구현은 자식클래스마다 완성한다)

	Parent 클래스(부모)
	Child1 클래스(자식) -> method1()을 선언한다
	Child2 클래스(자식) -> method1()을 선언한다

	getChild(Parent parent1)
		parent1.method1();
	
	* 각각의 클래스에서 메소드를 선언하면, up casting
	된 상태에서 사용할수 없다(자식 클래스 메소드이므로)
	그러나 추상메소드로 상속을 한다면, 모든 자식 클래스가
	재정의 했기때문에 up casting된 상태에서 호출 가능

	* 모든 자식 클래스에서 해당 메소드의 구현이 다르다 
	-> 추상메소드 : 재정의에 대한 강제성을 부여
	일부 자식 클래스에서만 구현이 다르다 
	-> 일반메소드 : 재정의에 대한 선택권이 존재


인터페이스(interface)
	
	값과 기능을 일관화 시키기 위한 틀






























