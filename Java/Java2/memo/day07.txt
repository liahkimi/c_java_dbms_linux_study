day07. 컬렉션 프레임워크, 쓰레드

복습

	ADT
		abstract data type
		

	자료구조
		자료(data)의 구조


	알고리즘
		문제 해결 절차 및 순서

자바의 자료구조
	컬렉션 프레임워크를 통해 구현된
	자료구조를 가져와서 사용한다

	컬렉션 프레임워크
		1. Collection 인터페이스
			List 인터페이스
				ArrayList 클래스
				LinkedList 클래스
				Vector 클래스

			Set 인터페이스
				HashSet 클래스
				TreeSet 클래스

		2. Map 인터페이스
			HahsMap 클래스
			TreeMap 클래스

		3. Collections 클래스

제네릭(generic)
	
	작성해야 하는 자료형이 아닌 일반화한 타입을 사용한다
	클래스나 메소드 선언시 데이터의 자료형을 일반화하여
	사용할 데이터 자료형을 컴파일때 지정하여 사용하는 방법

제네릭 선언 및 사용

	1. 선언 : 
	클래스명<타입변수>, 인터페이스<타입변수>

	타입변수 변수명;...
	타입변수 메소드명(자료형 매개변수명)...
	리턴타입 메소드명(타입변수 매개변수명)...

	2. 사용 :
	클래스명<타입> 객체명 = new 클래스<타입>();

ArrayList 클래스
	List 인터페이스를 구현한다
	배열과 달리 길이에 제한이 없이 사용할수 있다
	-> 데이터를 넣는대로, 데이터를 삭제하는대로 사용가능

	1. 추가
		add​(int index, E element)
			지정한 인덱스 자리에 새로운 요소 추가	
		add​(E e)
			마지막 자리에 새로운 요소 추가

	2. 삭제
		remove​(int index)	
			지정한 인덱스 자리의 요소 삭제
		remove​(Object o)
			전달한 요소가 있으면 첫번째로 발견한
			해당 요소 삭제

	3. 수정
		set​(int index, E element)
			지정한 인덱스 자리의 요소를 새로운
			요소로 수정

	4. 조회
		get(int index)
			지정한 인덱스 자리의 요소를 반환

Set
	Collection 인터페이스를 상속받는다

	집합과 유사하다
	데이터의 순서를 보장하지 않는다(순서가 없다)
	-> 인덱스 번호가 존재하지 않는다
	데이터의 중복을 허용하지 않는다

HashSet
	hashCode()가 반환하는 해시코드값을 이용하여
	데이터를 처리하며 속도가 상대적으로 빠르다
	
	중복된 값을 허용하지 않으며(중복된 값을 넣으면 무시된다)
	순서를 보장하지 않아 값의 존재여부를 파악할때 사용하기 좋다


	HashSet은 두 객체의 중복을 판단하기 위해서
	equals() 메소드와 hashCode() 메소드를 모두 사용한다
	그러므로 equals() 메소드와 hashCode() 메소드를 꼭
	같이 재정의해서 사용해야 한다

	hashCode() -> equals()

Iterator

	컬렉션에 저장된 데이터들을 컬렉션의 종류와 상관없이
	동일한 방식으로 가져오기 위한 인터페이스(타입)

	어떤 자료구조든지 Iterator로 변환하면 동일한 방식으로
	데이터를 가지고 올수 있다

	iterator() : 컬렉션 객체를 Iterator 타입으로
	변환할때 사용하는 메소드

	hasNext() : 다음값 존재 유무를 반환하는 메소드
	next() : 다음 값을 가져온다. 다음값이 존재하지 않으면
	예외가 발생한다

	ArrayList, HashSet, HashMap (컬렉션 객체) 
	-> 각각의 방법으로 데이터를 가져온다
	
	ArrayList, HashSet, HashMap 
	-> Iterator -> Itertaor 방식으로 데이터를 가져온다

Map
	데이터의 순서를 보장하지 않는다
	데이터를 key-value 한쌍으로 저장하여 
	key를 통해 데이터를 접근한다

	Key는 ArrayList의 index와 비슷한 역활을 하며
	중복을 허용하지 않는다 
	-> 주소에 중복이 있으면 안되는것과 동일
	-> index에 중복이 있으면 안되는것과 동일

HashMap
	key와 value 한쌍으로 데이터를 저장한다
	key를 통해서 value를 접근한다

	* key는 중복된 값이 허용되지 않는다
	Key가 중복된 Value를 추가하면 기존 Value가 수정된다
	Key가 중복되지 않은 Value를 추가하면 새로운 Value가 추가된다


	hashCode()가 반환하는 해시코드값을 이용하며
	검색 속도가 상대적으로 빠르다

JSON
	JSON(JavaScript Object Notation) 
	-> 자바스크립트 객체형식과 유사

	데이터를 표현하는 방법(단순 텍스트)
	데이터를 저장 및 전송할때 많이 사용되는 형식(format)이다

	
프로그램
	소스코드의 모음
	실행이 안된 상태

프로세스
	실행된 프로그램
	운영체제로부터 시스템 자원을 할당받는 작업의 단위
	시스템 자원(CPU, GPU, 메모리, 네트워크, 데이터 등...)
	
	프로그램 -- 본인이 사용해야하는 시스템 자원을 요청 ->  OS(운영체제)
	프로세스	<-- 시스템 자원을 할당 ----------------

쓰레드(thread)
	하나의 프로세스 내에서 실행되는 작업 단위
	-> 프로세스 처리 경로

	* 엑셀 프로그램 -> 엑셀 프로세스 -> 쓰레드1(인쇄), 쓰레드2(입력)..

단일(싱글) 쓰레드
	여러가지 일을 처리할 일꾼(쓰레드)가 1명이다

	순차적으로 실행된다(직렬적이다)
	-> 동시에 많은 양의 일을 처리하기 힘들기때문에
	상대적으로 비효율적이다

	하지만 하나의 일에 문제가 발생하더라도 다른 일에는
	영향을 끼치지 않는다

	[창구]	[인쇄][동영상보기][메세지보기]

	인쇄 완료 -> 동영상 보기 완료 -> 메세지 보기 완료

	* 창구가 1개이기때문에 인쇄와 동영상보기, 메세지보기를 동시에
	처리할수 없다. 즉, 인쇄가 끝나야 동영상을 보고, 동영상을 다 봐야
	메세지를 볼수 있다. 그러나 인쇄에 문제가 생기더라도 다른 작업은 아직
	시작하지 않았기 때문에 영향을 주지 않는다(안정성이 보장된다)


	* 1. A작업중 5번 출력
	  2. B작업중 5번 출력

	[싱글 쓰레드] 	[A작업중 5번 출력][B작업중 5번 출력]
	-> A작업중 5번 출력이 모두 완료되어야 B작업중이 5번 출력된다

	[멀티 쓰레드1]	[A작업중 5번 출력]
	[멀티 쓰레드2]	[B작업중 5번 출력]
	-> A작업중 출력이 진행되면서 B작업중 출력도 같이 진행된다

	* 자바 홈페이지(웹서버)
	[싱글 쓰레드]	[A유저 로그인][B유저 로그인]....
	-> A유저가 로그인이 끝나야 B유저가 로그인이 시작된다

	[멀티 쓰레드1]	[A유저 로그인]
	[멀티 쓰레드2]	[B유저 로그인]
	-> A유저가 로그인되지 않아도 B유저가 로그인이 시작된다

멀티 쓰레드
	
	하나의 프로세스에서 여러개의 쓰레드가 자원을 공유하며
	일을 나누어 수행하는것

	하나의 프로세스에서 동시에 처리하는것 처럼 보이지만,
	사실은 매우 짧은 단위로 일을 나누어 전환하며 처리한다
	-> 동시 작업이 가능해진다

	설계하기가 싱글 쓰레드에 비해 어려우며, 하나의 쓰레드에
	문제가 발생시 모든 쓰레드에 문제가 발생할수 있다

	멀티 쓰레드로 설계했다면, 처리량 증가, 효율성 증가, 처리비용의
	감소등의 장점이 있기때문에 해당 단점을 감수하고 사용한다
	
	* 자바의 웹서버가 대표적인 멀티 쓰레드

멀티 쓰레드 구현 방법

	1. Thread 클래스 상속 후 run() 메소드 재정의
	2. Runnable 인터페이스 구현 후 run() 메소드 재정의

	* run() 메소드 재정의

쓰레드 동작 과정

	1. Thread 클래스 상속 또는 Runnable 인터페이스 구현을
	통해서 run() 메소드 재정의
	2. 쓰레드 객체 생성(클래스 객체화)
	3. start() 메소드 호출(JVM에게 해당 작업을 멀티쓰레드로
	처리해달라는것을 요청)
	4. 쓰레드 실행
	5. 쓰레드 종료

쓰레드의 상태

	NEW : 아직 시작되지 않은 상태(쓰레드 객체 생성)
	RUNNABLE : 실행중인 상태, 실행가능한 상태
	BLOCKED : 동기화 처리에 의해 일시정지된 상태
	WAITING : 일시 정지 상태
	TIME_WAITING : 시간이 지정된 일시정지된 상태
	TERMINATED : 종료 상태

동기화
	하나의 쓰레드가 자원에 접근중일때 다른 쓰레드가 동시에
	같은 자원을 접근하지 못하게 막는것
	-> 자원 공유 문제를 해결할수 있다
	




	



















