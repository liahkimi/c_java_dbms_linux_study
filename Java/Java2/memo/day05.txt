day05. 마커 인터페이스, API, 예외처리

복습
	추상 클래스
		추상 메소드를 1개 이상 가진 
		클래스

	인터페이스
		공통의 값과 기능을 제공하는 틀

	상속과 구현
		상속(extends)
			기존 클래스의 멤버와
			타입을 상속받는다

		구현(implements)
			인터페이스의 
			추상메소드를 구현한다

		* 자바는 클래스의 단일상속
		* 자바는 인터페이스의 다중구현
		* 상속과 구현은 별개이므로
		하나의 클래스가 상속과 구현을 
		동시에 할수 있다
	
마커 인터페이스(marker interface)

	클래스들을 그룹화 하기 위한 목적으로 사용한다
	인터페이스는 구현한 클래스들의 상위 타입이며,
	구현 클래스의 객체는 인터페이스의 타입을 가지므로,
	마커 인터페이스를 구현하는 클래스들이 하나의 타입으로
	묶이게 된다

	-> 상속은 단일상속 밖에 되지 않으므로 인터페이스를 사용

API(Application Programming Interface)
	
	개발에 필요한 라이브러리들의 집합
	라이브러리 : 개발자가 만들어놓은 소스코드의 집합

	* 라이브러리와 프레임워크
		라이브러리 : 도구 
		프레임워크 : 도구와 환경

내부 API
	JDK 설치시 기본 제공해주는 API
	자바로 어플리케이션을 쉽게 구현할수 있도록 한
	라이브러리의 집합

	https://docs.oracle.com/en/java/javase/11/docs/api/

java.lang 패키지
	
	프로그래밍에 필요한 가장 기본적인 클래스들이 모여 있는 패키지
	import 없이 사용 가능하다

	1. Object 클래스 : 자바의 최상위 클래스 이용
	2. System 클래스	: 시스템의 표준입출력 장치로부터 데이터를
	입력받거나 출력하기 위해 사용
	3. String 클래스 : 문자열을 저장하고 여러가지 정보를 얻을때 사용
	4. StringBuffer, StringBuilder 클래스 : 문자열을 저장하고
	내부 문자열을 조작할때 사용
	5. Math 클래스 : 수학 함수를 이용할때 사용

외부 API
	다른 개발자들이 개발한 패키지 및 클래스들을 의마한다
	보통 JAR 파일로 배포하며, 자바 프로젝트에 build path에 
	추가하여 사용한다

외부 API 추가

	1. 배포된 JAR 파일 다운로드
	2. 추가할 프로젝트 마우스 우클릭 > build path 클릭
	> configure build path... 클릭
	3. libraries 탭 클릭 > class path 클릭 
	> add External Jar 클릭 > 저장된 경로의 .jar 파일 클릭해서 추가
	4. Order and Exports 탭 클릭 > select All 클릭
	5. Apply and Close 클릭

JAR 파일 배포(API 배포)

	1. 배포할 클래스 또는 패키지 우클릭
	2. Export 클릭 > JAVA/Jar file 선택 > Next 클릭
	3. destination 을 원하는 경로와 파일명을 작성해서 선택
	> Export Java source files... 체크
	4. Finish 클릭

API 주석(어노테이션 주석)
	
	/**

	**/

	@author : 작성자
	@since : jdk 버전 설명
	@param : 메소드의 매개변수 설명
	@return : 메소드의 리턴값 설명


오류의 종류

	에러(Error) : 개발자가 해결할수 없는 문제(코드로 수습 불가)
	예외(Exception) : 개발자가 해결할수 있는 문제(코드로 수습 가능)

예외 처리
	예상되는 예외를 적절한 처리를 하여 프로그램의 비정상적인 종료를 막는다

예외의 발생 시점
	
	자바에서는 런타임시 발생할 수 있는 예외를 클래스로 정의해두었다
	그러므로 해당 예외가 발생하면 예외객체가 메모리에 할당되고(객체화),
	그 객체의 주소값을 예외처리를 하느냐 하지 않느냐에따라 프로그램이 
	종료된다

	-> JVM이 예외 발생시 예외 클래스를 객체화 시키고
	해당 예외 객체를 처리하지 않으면 JVM이 프로그램을 종료시킨다

	1. 코드 진행중 예외가 발생하면 JVM에게 알린다
	2. JVM은 발생한 예외를 분석하여 알맞은 예외 클래스를 생성한다(객체화)
	3. 생성한 예외 객체를 발생한 지점으로 보낸다
	4. 예외가 발생한 지점에서 처리하지 않으면 프로그램을 종료시킨다

	1. 확인된 예외(checked exception)
		컴파일 단계에서 발생하는 오류(이클립스 빨간줄)
	2. 미확인 예외(unchecked exception)
		프로그램 실행중(런타임)에 발생하는 오류
	
예외처리 문법
	
	try{
		예외가 발생할 수 있는 코드
	}catch(예외클래스1 객체명) {
		예외1가 발생하면 실행할 코드
	}catch(예외클래스2 객체명) {
		예외2가 발생하면 실행할 코드
	}
	...
	finally{
		예외 발생 여부와 상관없이 실행할 코드
	}


	* finally : 외부 장치와 연결했을 경우 다시 연결을 종료할때
	주로 사용된다(파일, 네트워크, 데이터베이스 등...)
	
	* catch문은 위에서 아래로 검사하므로 해당 catch문에서
	예외가 잡히면 다른 catch문은 건너띈다

	* 모든 예외클래스의 부모는 Exception 클래스이다

예외클래스에서 제공하는 메소드

	1. getMessage() : 예외 메세지를 문자열로 반환함
	2. printStatckTrace() : 예외 발생 지점을 추적하여 단계별로
	전부 출력함
	3. toString() : 발생한 예외 객체를 문자열로 반환함(예외클래스명)

throws(예외처리 회피)
	
	예외를 던지기. 메소드의 선언부에서 사용한다
	메소드에서 발생할 수 있는 예외를 메소드를 정의할때(선언할때) 처리하지
	않고, 해당 메소드를 사용하느쪽으로 던져서 메소드를 사용하는 부분에서
	처리하도록 한다(상황에 따라 맞게 처리하기 위해서)


	리턴타입 메소드명(자료형 매개변수명) throws 예외명{

		실행할 코드
		...
		try-catch 블록 -> 메소드 정의시 예외처리

	}

	try{
		객체명.메소드명(); -> 메소드 호출시 예외처리

	}



throw(예외 발생)
	
	예외 발생 상황이 아니더라도 필요에 의해 강제로 예외를 발생시킨다
	throw new 예외명(메세지);

사용자 정의 예외
	
	public class 예외명 extends Exception {
		
		생성자(예외 메세지) {
			super(사용자 정의 예외 메세지);
		}

	}


	* extends Exception : 일반예외(checked exception)
	* extends RuntimeException : 실행예외(unchecked exception)

Object 클래스
	
	모든 클래스의 최상위 부모클래스
	-> 모든 클래스는 반드시 Object 클래스를 상속받는다
	-> 모든 클래스는 Object 클래스 타입과 멤버를 가진다

	1. equals() 
	2. hashCode()
	3. toString()

	* 위의 3개의 메소드는 필요에 따라 자식 클래스에서 재정의하여 사용한다














