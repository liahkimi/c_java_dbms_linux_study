day07. 메소드, 클래스

복습
	메소드(method)
		기능을 구현하기 위한 특정
		코드들의 묶음
		* 이름 뒤에 소괄호가 온다
		* 하나의 메소드는 하나의 기능만 담당한다

	메소드의 사용목적
		1. 소스코드의 간결화
		2. 코드의 재사용
		3. 모듈화(부품화)
		

	메소드 선언과 구현
	
	리턴타입 메소드명(자료형 매개변수)-> 선언부
	{			    -> 구현부
		실행할 코드
		return;
	}	

	* 리턴타입
		리턴값이 없을 경우에는 void
		리턴값이 있을 경우에는 해당 자료형

	* 메소드명
		동사의 형태로 작성한다

	* 자료형 매개변수
		외부에서 전달받은 값을 저장할 변수

	* 실행할 코드
		- return 리턴값

	메소드의 선언과 호출(사용)
		선언 : {} 중괄호가 있고, 반드시 다른
		메소드 밖에서 선언
		호출 : {} 중괄호가 없고, 반드시 다른
		메소드 안에서 호출(사용)

	메소드 선언 복습
		정수의 7의 배수 여부를 판별하는 메소드

		boolean isSevenMultiple(int num){
			return num % 7 == 0 ? true : false;
		}

	메소드 호출 복습
		객체명.isSevenMultiple(27);

인수와 매개변수
	인수(Argument)
		메소드를 호출할때 메소드의 매개변수로
		전달될 값
	매개변수(Parameter)
		외부에서 값을 전달받아 저장할 변수

메소드 오버로딩(Overloading)
	매개변수를 달리하여 같은 이름의 메소드를 중복하여
	선언하는것

	* 리턴타입은 오버로딩에 영향을 미치지 않는다
	-> 리턴타입은 변경해도 오버로딩 할수 없다

	int sum(int num1, int num2) {
		return num1 + num2;
	}

	int sum(int num1, int num2, int num3) {
		return num1 + num2 + num3;
	}

	-> 메소드의 매개변수 개수, 순서, 자료형이 다르면

	* println() : 메소드 오버로딩 되어있다
	System.out.println(10);
	System.out.println("hello");
	System.out.println(true);

객체 지향 프로그래밍(OOP : Ojbect-Oriented Programming)

	객체를 지향하는 프로그래밍 방법
	객체를 중심으로 프로그램 구조를 설계하고 프로그래밍 하는것

	1. 캡슐화 : 객체 내부의 멤버를 객체 외부에서 볼수 없도록
	캡슐화한다. 접근이 필요한 값의 경우 public 메소드를 활용
	하여 접근하고, 이외의 값들은 모두 캡슐화를 통해 정보를 
	은닉한다

	2. 추상화 : 공통된 기능과 정보를 추출해 객체화한다 

	3. 상속 : 미리 정의된 부모 클래스의 모든 멤버를 
	자식클래스가 물려받는다

	4. 다형성 : 하나의 방법으로 여러 객체를 호출하여 사용한다

클래스(class)

	1. 객체를 생성하기 위한 틀, 설계도
		자전거 틀(클래스)
		자전거1, 자전거2, 자전거3(객체)
	
	2. 연관성 있는 값과 기능을 한곳에 모아 편리하게 
	관리할 수 있는것

	3. 타입(사용자 정의 타입)

객체(object)
	실제 세계에 존재하는 모든것
	모든 객체는 상태(state)와 행동(behavior)을 가진다

	공통적인 상태, 공통적인 기능을 설계도에 담아
	새로운 객체가 필요할때 설계도를 통해 생성한다

클래스 선언
	
	class 클래스명{
		필드(field)
		메소드(method)
		* 생성자
	}

	1. 필드 : 변수. 객체가 가지고 있는 상태를 표현하는 변수
	-> 클래스 내에 정의되고 객체가 생성될때 객체와 함께 존재
	하는 데이터

	2. 메소드 : 기능. 객체가 가지고 있는 행동을 표현하기 위한
	코드들의 묶음

객체화(Instantiation)
	객체를 만드는(생성) 작업
	추상적인 개념(클래스)를 구체화하는 작업

	클래스명 객체명 = new 클래스명();

	* Scanner sc = new Scanner();
	-> heap 메모리 영역에 할당된 Scanner 클래스로
	생성한 객체의 주소값을 Scanner 클래스 타입의 변수
	sc에 저장한다

	* MyBike mb = new MyBike();
	-> heap 메모리 영역에 할당된 MyBike 클래스로 
	생성한 객체의 주소값을 MyBike 클래스 타입의 변수
	mb에 저장한다

	System.out.println(ar); -> 배열의 주소값
	System.out.println(mb); -> 객체의 주소값

멤버의 사용
	1. 필드 사용
		객체명.필드명;
		-> 변수에 담긴 객체의 주소값을 통해
		heap 메모리 영역에 생긴 객체가 가지고 있는
		필드를 사용한다

	2. 메소드 사용
		객체명.메소드명();
		-> 변수에 담긴 객체의 주소값을 통해
		heap 메모리 영역에 생긴 객체가 가지고 있는
		메소드를 사용한다

생성자(constructor)
	
	이름과 리턴타입, 역활이 정해져있는 메소드 중 하나
	객체가 생성될때 호출되어 객체를 초기화 한다(필드 초기화)

	클래스명(자료형 매개변수명) {
		초기화 코드
	}
	
	* 리턴타입이 void로 지정되어 있다(작성시 생략)
	* 이름이 클래스명으로 지정되어 있다(첫글자 대문자)
	* new 연산자를 통해 호출한다


	// 연습
	Car 클래스 선언
		색상, 제조사명, 가격, 좌석수 상태를 가진다
		-> 각각의 자동차 객체마다 상태값은 다르다

		엔진을 킵니다, 엔진을 끕니다 기능을 가진다
		-> startEngine(), turnOffEngine()
		-> 각각의 기능을 출력하는 메소드




















	
	








	
		